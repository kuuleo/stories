# I have a store that has a user object for the user's profile and preferences.  The thing that made me start this story is that I wanted to selectUser from the store using a selector.  Or getUser as I was using in Angular


* [ ] inject the `store: RootState` in to the CurrentUser.tsx component

Before, just to get the user working, I had this:
```
  reducer: {
    user: userReducer,
  },
```

* [x] use the format from 'the-next-drifter' by using `reducer: rootReducer`

* [x] create the rootReducer file

* [x] `yarn add redux@4.2.0 redux-observable`

* [ ] define typed hooks for `RootState` and `AppDispatch`
```
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'
import type { RootState, AppDispatch } from './store'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch: () => AppDispatch = useDispatch
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector
```

If I have a rootReducer that I'm importing in my `store/index.ts`, then I shouldn't need to also import the following
```
import userReducer from './features/user/slice'
```
* [ ] remove it and confirm that this line provide all the reducers
```
import rootReducer from './rootReducer'
```

* [ ] create `rootEpic`

WHEN the actions are autogenerated by the slice from reduxjs/toolkit, they are in this format:
`user/userDataReceived`
... the directory of the slice followed by the reducerFunction

The simplest stream I could make in an effect would be 1 action in and one action out.  I could use map if I'm am changing the input stream, say modifiying something in the action going in but I'll use mapTo since I am changing the stream into a value which is not related to the emitted action coming in.

* [ ] use `mapTo` to for a basic test that the epic is working send in `signOutRequest` and `mapTo` a `signOutSuccess` without any request being made in the middle


## MP20 Confirm that the store is a hot observable and if it is not, then make it one.

By store, I guess I'm referring to the Provider tag, at least the input variable `{store}`.

For ngrx, I was doing this.store.select(...)

... and REF https://stackoverflow.com/questions/62425558/ngrx-selector-cold-or-hot-observable

`this.store.select(...)`
is basically just
```
this.store$.pipe(
  map(...),
  distinctUntilChanged()
)
```

In Angular, my selectors were cold observables.

I can wrap anything and it becomes an observable.  Meaning I can wrap the react redux store as an observable.  I don't see WHY I couldn't pass an observable as the variable to the store attribute in the Provider reducerFunction

REF the post for wraping store as an observable: https://github.com/reduxjs/redux/issues/303#issuecomment-125184409

And then I know that Angular is a shitload of code.  A lot of it is good I'm sure.  And a lot of it is not necessary I'm also sure.

??HOW do i make the store a trickle down observable stream that would take actions in as inputs and do it's thing with effect and reducers.  This woudl mean I would be passing an actions stream to the reducers function, which Ngrx has as a BehaviorSubject I believe.  and the passing an actions stre to the epic middleward which shouldn't be a problem since that part is already using rxjs.  Then I could use the code from stackoverflow on angular selectors under the hood for how they stay cold until they receive new stuff and do that for my selectors that I would import into the components that will use them.  
Then I want to change the functionality so that when I dispatch an action, I would be just droping and action observable into the actions pipe line

REF ngrx docs...

WHEN they create an instance of their Store, it:

* `extends Observable<T>`
* `implements Observer<Action>`

Then they define a bunch of different select functions, which I guess are overloads. I normally import select from @ngrx/store, which should mean that they export a select from the `@ngrx/store` module.  Their select functions take an Observable source$ as their first argument.

So the first select function, they are ...

... wait a sec... 

I've never been completely clear on Typescript <> stuff. But from this `stackoverflow` REF I see that:

`type Pair<U,V> = [U, V]`
if you give `Pair` `number` `string` like this:
  `Pair<number, string>`
  Then, I'll get and array back of the type [number, string]

  <T> ... WHATever is passed in is the type that is acceptable
  ... T captures whatever type is passed in 

  <T extends object> says the type passed in must be an object

  <T extends SomeInterface> says type passed in must be of that interfact

```
interface Resource<T> {
  uid: number;
  resourceName: string;
  data: T;
}
```
The above states that this interface says that I can pass in anytype of data.  The `T` part means that the data will be set to the type of the thing passed in.  So I can pass stuff into interfaces...??  I guess that just means I can stipulate that the `Resource` WHEN I use the interface, I can include a type with my stipulation.  So I can say something like `Resource<User>`
... and then the `Resource` will have to be in the format:
```
{
    uid: number;
    resourceName: string;
    data: User;
  }
```

But at the and of the day, the thing that got me down this whole Observable is because I want to be able to pipe my selectors so that new data comes in as it comes in 

* [ ] so first write a selectors file

* [ ] then have it select user

* [ ] the use create selector to do the logic for user or slug based on name being there

I don't want it to rerender the user component unnecessarily 

* [ ] first just call the selectUserName(state)... using the state as it is 


If I want to have a store that is like ngrx's store, it should be an observable

... and if I want it to have a select method

Ngrx has these attributes in its constructor function for `class Store`
* state$ of type `StateObservable` defined in `state.ts`
* actionsObserver of type `ActionsSubject` defined in `actions_subject`
* `reducerManager` of type `ReducerManager` defined in `reducer_manager`

### NGRX StateObservable from './state'


StateObservable is exported from the state files as an abstract class.  Tutorialsteacher.com says that "define an abstract class... mainly for inheritance where other classes may derive from them... pointing out that instances of an abstract class cannot be made."

The class which extends the abstract class must define all the abstract methods of the abstract class.

If there is a abstract class Person with an abstract method find and Employee class extends Person.  Since Employee is extends Person, it must define the find method as abstract.  The Employee class must implement all the abstract methods of the Person class otherwise the compiler will show an error.  It can do this simply by calling super()...

But, the state.ts file doesn't do much with StateObservable.

1. it includes it in the STATE_PROVIDERS array... 2nd object, under the provide key

2. it export it as an empty Observable<any> like this:
`export abstract class StateObservable extends Observable<any> {}`
I guess in this case, the extends Observable is just like calling super() when defining the Employee class.
So this would mean that StateObservable is exactly the same as Observable<any> since it does not define anything in addition to Observable<any>.
Observable is imported from rxjs so it it not a specific Angular implementation.

?? Redux subscribing to store is subscribing to an Observable...??
